<!DOCTYPE html>
  
  
  
  
   <html class="no-js"> 

  <head lang="en-us">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=10" />
    <title>API Reference - Okapi Docs</title>
    <meta name="generator" content="Hugo 0.31.1" />

    
    <meta name="description" content="A PROS library for fast C&#43;&#43; development.">
    
    <link rel="canonical" href="https://okapilib.github.io/OkapiLib/api/">
    
    <meta name="author" content="OkapiLib">
    

    <meta property="og:url" content="https://okapilib.github.io/OkapiLib/api/">
    <meta property="og:title" content="Okapi Docs">
    <meta property="og:image" content="https://okapilib.github.io/OkapiLib/images/okapi.jpg">
    <meta name="apple-mobile-web-app-title" content="Okapi Docs">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <link rel="shortcut icon" type="image/x-icon" href="https://okapilib.github.io/OkapiLib/images/favicon.ico">
    <link rel="icon" type="image/x-icon" href="https://okapilib.github.io/OkapiLib/images/favicon.ico">

    <style>
      @font-face {
        font-family: 'Icon';
        src: url('https://okapilib.github.io/OkapiLib/fonts/icon.eot');
        src: url('https://okapilib.github.io/OkapiLib/fonts/icon.eot')
               format('embedded-opentype'),
             url('https://okapilib.github.io/OkapiLib/fonts/icon.woff')
               format('woff'),
             url('https://okapilib.github.io/OkapiLib/fonts/icon.ttf')
               format('truetype'),
             url('https://okapilib.github.io/OkapiLib/fonts/icon.svg')
               format('svg');
        font-weight: normal;
        font-style: normal;
      }
    </style>

    <link rel="stylesheet" href="https://okapilib.github.io/OkapiLib/stylesheets/application.css">
    <link rel="stylesheet" href="https://okapilib.github.io/OkapiLib/stylesheets/temporary.css">
    <link rel="stylesheet" href="https://okapilib.github.io/OkapiLib/stylesheets/palettes.css">
    <link rel="stylesheet" href="https://okapilib.github.io/OkapiLib/stylesheets/highlight/highlight.css">

    
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ubuntu:400,700|Ubuntu&#43;Mono">
    <style>
      body, input {
        font-family: 'Ubuntu', Helvetica, Arial, sans-serif;
      }
      pre, code {
        font-family: 'Ubuntu Mono', 'Courier New', 'Courier', monospace;
      }
    </style>

    
    <link rel="stylesheet" href="https://okapilib.github.io/OkapiLib/css/imageAlign.css">
    
    <script src="https://okapilib.github.io/OkapiLib/javascripts/modernizr.js"></script>

    

  </head>
  <body class="palette-primary-red palette-accent-teal">



	
	


<div class="backdrop">
	<div class="backdrop-paper"></div>
</div>

<input class="toggle" type="checkbox" id="toggle-drawer">
<input class="toggle" type="checkbox" id="toggle-search">
<label class="toggle-button overlay" for="toggle-drawer"></label>

<header class="header">
	<nav aria-label="Header">
  <div class="bar default">
    <div class="button button-menu" role="button" aria-label="Menu">
      <label class="toggle-button icon icon-menu" for="toggle-drawer">
        <span></span>
      </label>
    </div>
    <div class="stretch">
      <div class="title">
        API Reference
      </div>
    </div>

    

    
    <div class="button button-github" role="button" aria-label="GitHub">
      <a href="https://github.com/OkapiLib" title="@OkapiLib on GitHub" target="_blank" class="toggle-button icon icon-github"></a>
    </div>
    
    
        
  </div>
  <div class="bar search">
    <div class="button button-close" role="button" aria-label="Close">
      <label class="toggle-button icon icon-back" for="toggle-search"></label>
    </div>
    <div class="stretch">
      <div class="field">
        <input class="query" type="text" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck>
      </div>
    </div>
    <div class="button button-reset" role="button" aria-label="Search">
      <button class="toggle-button icon icon-close" id="reset-search"></button>
    </div>
  </div>
</nav>
</header>

<main class="main">
	<div class="drawer">
		<nav aria-label="Navigation">
  <a href="https://github.com/OkapiLib/OkapiLib" class="project">
    <div class="banner">
      
        <div class="logo">
          <img src="https://okapilib.github.io/OkapiLib/images/okapi.jpg">
        </div>
      
      <div class="name">
        <strong>Okapi Docs <span class="version">0.3.0</span></strong>
        
          <br>
          OkapiLib/OkapiLib
        
      </div>
    </div>
  </a>

  <div class="scrollable">
    <div class="wrapper">
      
        <ul class="repo">
          <li class="repo-download">
            <a href="https://github.com/OkapiLib/OkapiLib/archive/master.zip" target="_blank" title="Download" data-action="download">
              <i class="icon icon-download"></i> Download
            </a>
          </li>
          <li class="repo-stars">
            <a href="https://github.com/OkapiLib/OkapiLib/stargazers" target="_blank" title="Stargazers" data-action="star">
              <i class="icon icon-star"></i> Stars
              <span class="count">&ndash;</span>
            </a>
          </li>
        </ul>
        <hr>
      

      <div class="toc">
        
        <ul>
          




<li>
  
    



<a  title="Home" href="https://okapilib.github.io/OkapiLib/home/">
	
	Home
</a>



  
</li>



<li>
  
    



<a  title="Getting started" href="https://okapilib.github.io/OkapiLib/getting-started/">
	
	Getting started
</a>



  
</li>



<li>
  
    



<a  title="Tutorials" href="https://okapilib.github.io/OkapiLib/tutorials/">
	
	Tutorials
</a>



  
</li>



<li>
  
    



<a class="current" title="API" href="https://okapilib.github.io/OkapiLib/api/">
	
	API
</a>


<ul id="scrollspy">
</ul>


  
</li>



<li>
  
    



<a  title="License" href="https://okapilib.github.io/OkapiLib/license/">
	
	License
</a>



  
</li>


        </ul>
        

        
        <hr>
        <span class="section">The author</span>
        
        <ul>
          

          
          <li>
            <a href="https://github.com/OkapiLib" target="_blank" title="@OkapiLib on GitHub">
              @OkapiLib on GitHub
            </a>
          </li>
          

          
        </ul>
        
      </div>
    </div>
  </div>
</nav>

	</div>

	<article class="article">
		<div class="wrapper">
			<h1>API Reference </h1>

			<p>This section is meant to be a quick reference for Okapi&rsquo;s entire API, including methods the user may not normally interact with. This reference is broken into sections, covering one class per section. Subclasses are placed below the base class, but in different sections. If a class is marked (abstract) then it contains one or more pure virtual functions, and cannot be instantiated (it is designed only to be an interface).</p>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Remember that derived classes inherit the interface of their base class; therefore, derived classes will not have their base class&rsquo; functions documented (you can safely assume that all functions from the base class are implemented).</p>
</div>

<p><h2 id="avgfilter">AvgFilter</h2>

<p>The <code>AvgFilter</code> class inherits from <code>Filter</code> and takes a template parameter <code>std::size_t n&gt;</code> (the number of inputs to average). It is a finite impulse response (FIR) filter that averages the last <code>n</code> inputs.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
AvgFilter()
</code></pre>

<p>The constructor does not take any parameters.</p>

<h2 id="button">Button</h2>

<p>The <code>Button</code> class is a sample wrapper around a digital input port that represents a button.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
explicit constexpr Button()
explicit constexpr Button(const unsigned char iport, const bool iinverted = false)
explicit constexpr Button(const unsigned char ijoystick, const unsigned char ibuttonGroup, const unsigned char ibutton, const bool iinverted = false)
explicit constexpr Button(PROS_FILE* ilcdPort, const unsigned char ilcdButton, const bool iinverted = false)
</code></pre>

<p>Button or limit switch constructor:</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iport</td>
<td>Digital port</td>
</tr>

<tr>
<td>iinverted</td>
<td>Whether the button is inverted (default open vs. default closed)</td>
</tr>
</tbody>
</table>

<p>Joystick button constructor:</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ijoystick</td>
<td>Joystick number (primary (1) or partner (2))</td>
</tr>

<tr>
<td>ibuttonGroup</td>
<td>Joystick button group</td>
</tr>

<tr>
<td>ibutton</td>
<td>Button in button group</td>
</tr>

<tr>
<td>iinverted</td>
<td>Whether the button is inverted (default open vs. default closed)</td>
</tr>
</tbody>
</table>

<p>LCD button constructor:</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ilcdPort</td>
<td>LCD port (uart1 or uart2)</td>
</tr>

<tr>
<td>ilcdbutton</td>
<td>LCD button mask</td>
</tr>

<tr>
<td>iinverted</td>
<td>Whether the button is inverted (default open vs. default closed)</td>
</tr>
</tbody>
</table>

<p>This class also has literals available:</p>

<table>
<thead>
<tr>
<th>Literal</th>
<th>Button Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>n_b</code></td>
<td><code>Button(n, false)</code></td>
</tr>

<tr>
<td><code>n_ib</code></td>
<td><code>Button(n, true)</code></td>
</tr>
</tbody>
</table>

<h3 id="ispressed">isPressed</h3>

<pre><code class="language-c++">//Signature
bool isPressed() const
</code></pre>

<p>Return whether this button is pressed or not. This takes into account whether the button is inverted or not.</p>

<h3 id="edge">edge</h3>

<pre><code class="language-c++">//Signature
bool edge()
</code></pre>

<p>Return <code>true</code> if a rising or falling edge is detected. This takes into account whether the button is inverted or not.</p>

<h3 id="risingedge">risingEdge</h3>

<pre><code class="language-c++">//Signature
bool risingEdge()
</code></pre>

<p>Return <code>true</code> if a rising edge is detected. This takes into account whether the button is inverted or not.</p>

<h3 id="fallingedge">fallingEdge</h3>

<pre><code class="language-c++">//Signature
bool fallingEdge()
</code></pre>

<p>Return <code>true</code> if a falling edge is detected. This takes into account whether the button is inverted or not.</p>

<h2 id="chassiscontroller-abstract">ChassisController (abstract)</h2>

<p>The <code>ChassisController</code> class an interface for controlling a robot&rsquo;s chassis: it provides methods that build upon the basic methods <code>ChassisModel</code> has for more accurate control.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
ChassisController(const ChassisModelParams&amp; imodelParams)
ChassisController(std::shared_ptr&lt;ChassisModel&gt; imodel)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imodelParams</td>
<td><code>ChassisModelParams</code> (used to make a new <code>ChassisModel</code>)</td>
</tr>

<tr>
<td>imodel</td>
<td>An existing <code>ChassisModel</code></td>
</tr>
</tbody>
</table>

<h3 id="drivestraight">driveStraight</h3>

<pre><code class="language-c++">//Signature
virtual void driveStraight(const int itarget) = 0
</code></pre>

<p>Drive the robot straight for a distance of <code>itarget</code> in the units of <code>itarget</code>.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>itarget</td>
<td>Distance for the robot to travel</td>
</tr>
</tbody>
</table>

<h3 id="pointturn">pointTurn</h3>

<pre><code class="language-c++">//Signature
virtual void pointTurn(const float idegTarget) = 0
</code></pre>

<p>Turn the robot in place for an angle of <code>idegTarget</code>. The units of the angle travel is most often the difference in encoder ticks between the two sides of the chassis.</p>

<h3 id="driveforward">driveForward</h3>

<pre><code class="language-c++">//Signature
void driveForward(const int power)
</code></pre>

<p>Passthrough function to call <code>driveForward</code> on the internal <code>ChassisModel</code>.</p>

<h3 id="drivevector">driveVector</h3>

<pre><code class="language-c++">//Signature
void driveVector(const int distPower, const int anglePower)
</code></pre>

<p>Passthrough function to call <code>driveVector</code> on the internal <code>ChassisModel</code>.</p>

<h3 id="turnclockwise">turnClockwise</h3>

<pre><code class="language-c++">//Signature
void turnClockwise(const int power)
</code></pre>

<p>Passthrough function to call <code>turnClockwise</code> on the internal <code>ChassisModel</code>.</p>

<h3 id="tank">tank</h3>

<pre><code class="language-c++">//Signature
void tank(const int leftVal, const int rightVal, const int threshold = 0)
</code></pre>

<p>Passthrough function to call <code>tank</code> on the internal <code>ChassisModel</code></p>

<h3 id="arcade">arcade</h3>

<pre><code class="language-c++">//Signature
void arcade(int verticalVal, int horizontalVal, const int threshold = 0)
</code></pre>

<p>Passthrough function to call <code>arcade</code> on the internal <code>ChassisModel</code></p>

<h3 id="left">left</h3>

<pre><code class="language-c++">//Signature
void left(const int val);
</code></pre>

<p>Passthrough function to call <code>left</code> on the internal <code>ChassisModel</code>.</p>

<h3 id="leftts">leftTS</h3>

<pre><code class="language-c++">//Signature
void leftTS(const int val);
</code></pre>

<p>Passthrough function to call <code>leftTS</code> on the internal <code>ChassisModel</code>.</p>

<h3 id="right">right</h3>

<pre><code class="language-c++">//Signature
void right(const int val);
</code></pre>

<p>Passthrough function to call <code>right</code> on the internal <code>ChassisModel</code>.</p>

<h3 id="rightts">rightTS</h3>

<pre><code class="language-c++">//Signature
void rightTS(const int val);
</code></pre>

<p>Passthrough function to call <code>rightTS</code> on the internal <code>ChassisModel</code>.</p>

<h3 id="getencodervals">getEncoderVals</h3>

<pre><code class="language-c++">//Signature
std::valarray&lt;int&gt; getEncoderVals() const
</code></pre>

<p>Passthrough function to call <code>getEncoderVals</code> on the internal <code>ChassisModel</code>.</p>

<div class="admonition warning">
<p class="admonition-title">Careful</p>
<p>Most users should not call this constructor with a std::shared_ptr&lt;ChassisModel&gt;. Instead, pass a ChassisModelParams and Okapi will figure out what to do.</p>
</div>
<h2 id="chassiscontrollerpid">ChassisControllerPid</h2>

<p>The <code>ChassisControllerPid</code> class inherits from <code>ChassisController</code> and implements its interface using PID control.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
ChassisControllerPid(const ChassisModelParams&amp; imodelParams, const PidParams&amp; idistanceParams, const PidParams&amp; iangleParams)
ChassisControllerPid(const std::shared_ptr&lt;ChassisModel&gt;&amp; imodel, const PidParams&amp; idistanceParams, const PidParams&amp; iangleParams)

//Make a new ChassisControllerPid using a skid steer model with two motors per side
ChassisControllerPid foo(
  SkidSteerModelParams&lt;2&gt;({1, 3, 2, 4}, //The four motor ports
                          encoderInit(1, 2, false), //Left encoder
                          encoderInit(3, 4, true)), //Right encoder
  PidParams(2, 0.1, 0.4),    //Distance PID controller
  PidParams(0.3, 1.2, 0.1)); //Angle PID controller
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imodelParams</td>
<td><code>ChassisModelParams</code> (used to make a new <code>ChassisModel</code>)</td>
</tr>

<tr>
<td>imodel</td>
<td>An existing <code>ChassisModel</code></td>
</tr>

<tr>
<td>idistanceParams</td>
<td><code>PidParams</code> for the distance PID controller</td>
</tr>

<tr>
<td>iangleParams</td>
<td><code>PidParams</code> for the angle PID controller</td>
</tr>
</tbody>
</table>

<div class="admonition warning">
<p class="admonition-title">Careful</p>
<p>Most users should not call this constructor with a std::shared_ptr&lt;ChassisModel&gt;. Instead, pass a ChassisModelParams and Okapi will figure out what to do.</p>
</div>
<h2 id="chassismodel-abstract">ChassisModel (abstract)</h2>

<p>The <code>ChassisModel</code> class is an interface to a robot&rsquo;s chassis: it provides methods to control the chassis and to read from standard sensors placed on most chassis (i.e., quadrature encoders).</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
ChassisModel()
</code></pre>

<p>The constructor does not take any parameters.</p>

<h3 id="driveforward">driveForward</h3>

<pre><code class="language-c++">//Signature
virtual void driveForward(const int power) = 0
</code></pre>

<p>Drives the chassis forwards by setting all motors to the input power. A positive value for <code>power</code> should cause all chassis wheels to move the robot forward in a straight line. Uses truespeed.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>power</td>
<td>The raw motor power sent directly to the chassis&rsquo; motors</td>
</tr>
</tbody>
</table>

<h3 id="turnclockwise">turnClockwise</h3>

<pre><code class="language-c++">//Signature
virtual void turnClockwise(const int power) = 0
</code></pre>

<p>Turns the robot clockwise by setting the left side motors to the input power and the right side motors to the negative of the input power. A positive value for <code>power</code> should cause all chassis wheels to turn the robot clockwise on a point. Uses truespeed.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>power</td>
<td>The raw motor power sent directly to the chassis&rsquo; motors</td>
</tr>
</tbody>
</table>

<h3 id="drivevector">driveVector</h3>

<pre><code class="language-c++">//Signature
virtual void driveVector(const int distPower, const int anglePower) = 0

driveVector(127, 0) //Same as driveForward(127)
driveVector(0, 127) //Same as turnClockwise(127)

//Make a moderate swing turn clockwise
//left motors get 110 power, right motors get 70 power
driveVector(90, 20)
</code></pre>

<p>Drive the chassis along a curved path. Calling <code>driveVector(127, 0)</code> should be equivalent to calling <code>driveForward(127)</code>; calling <code>driveVector(0, 127)</code> should be equivalent to calling <code>turnClockwise(127)</code>. A mix between the two will cause the robot to make a swing turn. Uses truespeed.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>distPower</td>
<td>The motor power making up the &ldquo;straight&rdquo; component of the final motor power</td>
</tr>

<tr>
<td>anglePower</td>
<td>The motor power making up the &ldquo;turn&rdquo; component of the final motor power</td>
</tr>
</tbody>
</table>

<h3 id="tank">tank</h3>

<pre><code class="language-c++">//Signature
virtual void tank(const int leftVal, const int rightVal, const int threshold = 0) = 0;
</code></pre>

<p>Power the motors like tank drive.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>leftVal</td>
<td>Motor power for the left side motors</td>
</tr>

<tr>
<td>rightVal</td>
<td>Motor power for the right side motors</td>
</tr>

<tr>
<td>threshold</td>
<td>Motor power below this threshold will become zero</td>
</tr>
</tbody>
</table>

<h3 id="arcade">arcade</h3>

<pre><code class="language-c++">//Signature
virtual void arcade(int verticalVal, int horizontalVal, const int threshold = 0) = 0;
</code></pre>

<p>Power the motors like arcade drive.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>verticalVal</td>
<td>Motor power for the vertical component of movement</td>
</tr>

<tr>
<td>horizontalVal</td>
<td>Motor power for the horizontal component of movement</td>
</tr>

<tr>
<td>threshold</td>
<td>Motor power below this threshold will become zero</td>
</tr>
</tbody>
</table>

<h3 id="left">left</h3>

<pre><code class="language-c++">//Signature
virtual void left(const int val) = 0;
</code></pre>

<p>Power the left side motors.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>val</td>
<td>Motor power</td>
</tr>
</tbody>
</table>

<h3 id="leftts">leftTS</h3>

<pre><code class="language-c++">//Signature
virtual void leftTS(const int val) = 0;
</code></pre>

<p>Power the left side motors using truespeed.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>val</td>
<td>Motor power</td>
</tr>
</tbody>
</table>

<h3 id="right">right</h3>

<pre><code class="language-c++">//Signature
virtual void right(const int val) = 0;
</code></pre>

<p>Power the right side motors.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>val</td>
<td>Motor power</td>
</tr>
</tbody>
</table>

<h3 id="rightts">rightTS</h3>

<pre><code class="language-c++">//Signature
virtual void rightTS(const int val) = 0;
</code></pre>

<p>Power the right side motors using truespeed.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>val</td>
<td>Motor power</td>
</tr>
</tbody>
</table>

<h3 id="getencodervals">getEncoderVals</h3>

<pre><code class="language-c++">//Signature
virtual std::valarray&lt;int&gt; getSensorVals() = 0
</code></pre>

<p>Reads the sensors given to the chassis model at construction time and returns them in the format <code>{left sensor value, right sensor value}</code>. Return type is a <code>std::valarray</code> because it features operator overrides for common math operations making encoder math easy.</p>

<h3 id="resetsensors">resetSensors</h3>

<pre><code class="language-c++">//Signature
virtual void resetSensors() = 0
</code></pre>

<p>Reset the sensors to zero.</p>

<h2 id="chassismodelparams-abstract">ChassisModelParams (Abstract)</h2>

<p>The <code>ChassisModelParams</code> class encapsulates the parameters a <code>ChassisModel</code> takes.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
ChassisModelParams()
</code></pre>

<p>The constructor does not take any parameters.</p>

<h3 id="make">make</h3>

<p>Allocate a new <code>ChassisModel</code> and return a <code>std::shared_ptr</code> to it. Most users will not have to call this, classes that take a <code>ChassisModel</code> will figure out the memory model themselves.</p>

<pre><code class="language-c++">//Signature
virtual std::shared_ptr&lt;ChassisModel&gt; make() const = 0
</code></pre>

<h2 id="controlobject-abstract">ControlObject (abstract)</h2>

<p>The <code>ControlObject</code> class is an interface to closed-loop controllers. It requires implementation of step, target, and output functions.</p>

<h3 id="step">step</h3>

<pre><code class="language-c++">//Signature
virtual float step(const float ireading) = 0
</code></pre>

<p>Do one iteration of the control math to compute a new motor power. Normally called in a loop.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ireading</td>
<td>New sensor reading</td>
</tr>
</tbody>
</table>

<h3 id="settarget">setTarget</h3>

<pre><code class="language-c++">//Signature
virtual void setTarget(const float itarget) = 0
</code></pre>

<p>Set the target value.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>itarget</td>
<td>New target value</td>
</tr>
</tbody>
</table>

<h3 id="getoutput">getOutput</h3>

<pre><code class="language-c++">//Signature
virtual float getOutput() const = 0
</code></pre>

<p>Return the most recent controller output.</p>

<h3 id="geterror">getError</h3>

<pre><code class="language-c++">//Signature
virtual float getError() const = 0
</code></pre>

<p>Return the most recent controller error.</p>

<h3 id="setsampletime">setSampleTime</h3>

<pre><code class="language-c++">//Signature
virtual void setSampleTime(const int isampleTime)
</code></pre>

<p>Set the timestep (in ms) between calls to <code>step</code>.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>isampleTime</td>
<td>Timestep between calls to <code>step</code> in ms</td>
</tr>
</tbody>
</table>

<h3 id="setoutputlimits">setOutputLimits</h3>

<pre><code class="language-c++">//Signature
virtual void setOutputLimits(float imax, float imin)
</code></pre>

<p>Set the max and min value for the controller output.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imax</td>
<td>Max output</td>
</tr>

<tr>
<td>imin</td>
<td>Min output</td>
</tr>
</tbody>
</table>

<h3 id="reset">reset</h3>

<pre><code class="language-c++">//Signature
virtual void reset()
</code></pre>

<p>Reset the controller so it will start from zero again.</p>

<h3 id="flipdisable">flipDisable</h3>

<pre><code class="language-c++">//Signature
virtual void flipDisable()
</code></pre>

<p>Change whether the controller is on or off. A controller which is off will output 0.</p>

<h2 id="cubicmotor">CubicMotor</h2>

<p>The <code>CubicMotor</code> class provides a cubic-control based implementation of the <code>set</code> function <code>Motor</code> defines. This means that the motor power from <code>set</code> follows a cubic curve instead of the default identity function. The <code>setTS</code> function is not overridden and so provides the same behavior as in <code>Motor</code>.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
explicit constexpr CubicMotor(const unsigned char iport, const int *its)
explicit constexpr CubicMotor(const unsigned char iport, const int isign = 1, const int *its = motor::trueSpeed)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iport</td>
<td>Motor port</td>
</tr>

<tr>
<td>isign</td>
<td><code>1</code> for forward, <code>-1</code> for reversed</td>
</tr>

<tr>
<td>its</td>
<td>TrueSpeed array to linearize the motor controller</td>
</tr>
</tbody>
</table>

<p>This class also has literals available:</p>

<table>
<thead>
<tr>
<th>Literal</th>
<th>Motor Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>n_m3</code></td>
<td><code>CubicMotor(m, 1)</code></td>
</tr>

<tr>
<td><code>n_rm3</code></td>
<td><code>CubicMotor(m, -1)</code></td>
</tr>
</tbody>
</table>

<h3 id="set">set</h3>

<pre><code class="language-c++">//Signature
virtual void set(const int val) const
</code></pre>

<p>Set the power of this motor using a cubic function. The exact math for the output of this function is <code>(val * val * val) / (127 * 127)</code>.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>val</td>
<td>Motor power</td>
</tr>
</tbody>
</table>

<h2 id="cubicslewmotor">CubicSlewMotor</h2>

<p>The <code>CubicSlewMotor</code> class adds a slew rate to the <code>CubicMotor</code> class.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
CubicSlewMotor(const CubicMotor&amp; imotor, const float islewRate)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imotor</td>
<td>Motor to slew</td>
</tr>

<tr>
<td>islewRate</td>
<td>Slew rate</td>
</tr>
</tbody>
</table>

<h3 id="set">set</h3>

<pre><code class="language-c++">//Signature
virtual void set(const int val) const
</code></pre>

<p>Slew the power of this motor up to <code>val</code>.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>val</td>
<td>Target motor power</td>
</tr>
</tbody>
</table>

<h3 id="setts">setTS</h3>

<pre><code class="language-c++">//Signature
virtual void set(const int val) const
</code></pre>

<p>Slew the power of this motor up to <code>val</code> using trueSpeed.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>val</td>
<td>Target motor power</td>
</tr>
</tbody>
</table>

<h2 id="demafilter">DemaFilter</h2>

<p>The <code>DemaFilter</code> class inherits from <code>Filter</code>. It is an infinite impulse response (IIR) filter that implements the double exponential moving average algorithm (EMA). This is very similar to the normal EMA, except it can pick up on trends in data and follow the current trend until a new trend starts. This filter performs better than a single EMA when data frequently follows a trend.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
DemaFilter(const float ialpha, const float ibeta)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ialpha</td>
<td>Alpha gain</td>
</tr>

<tr>
<td>ibeta</td>
<td>Beta gain</td>
</tr>
</tbody>
</table>

<h3 id="setgains">setGains</h3>

<pre><code class="language-c++">//Signature
void setGains(const float ialpha, const float ibeta)
</code></pre>

<p>Set new gains for this filter</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ialpha</td>
<td>New alpha gain</td>
</tr>

<tr>
<td>ibeta</td>
<td>New beta gain</td>
</tr>
</tbody>
</table>

<h2 id="distanceandangle">DistanceAndAngle</h2>

<p>The <code>DistanceAndAngle</code> class is a simple container for the two parameters returned by <code>OdomMath::computeDistanceAndAngleToPoint</code>.</p>

<table>
<thead>
<tr>
<th>Member</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>length</td>
<td>Distance to point</td>
</tr>

<tr>
<td>theta</td>
<td>Angle to point</td>
</tr>
</tbody>
</table>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
DistanceAndAngle(const float ilength, const float itheta)
DistanceAndAngle()
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ilength</td>
<td>Distance to point</td>
</tr>

<tr>
<td>itheta</td>
<td>Angle to point</td>
</tr>
</tbody>
</table>

<h2 id="ekffilter">EKFFilter</h2>

<p>The <code>EKFFilter</code> class inherits from <code>Filter</code>. It is a very simple implementation of a one-dimensional extended kalman filter. It does not have any internal model and it is only suited for filtering simple signals, such as a robot&rsquo;s velocity.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
EKFFilter(const float iQ = 0.0001,  const float iR = ipow(0.2, 2))
</code></pre>

<p>Process variance is an estimate of how inaccurate the model is. Measurement variance is an estimate of how noisy the sensor is. If you really want to dial in <code>R</code> yourself, then you can record unfiltered data of the process held constant at one state (the robot spinning in place at a constant motor power, for example). Then, you can subtract the estimated signal value from the data, leaving only the noise behind.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iQ</td>
<td>Process variance</td>
</tr>

<tr>
<td>iR</td>
<td>Measurement variance</td>
</tr>
</tbody>
</table>

<h2 id="emafilter">EmaFilter</h2>

<p>The <code>EmaFilter</code> class inherits from <code>Filter</code>. It is an infinite impulse response (IIR) filter that implements the exponential moving average algorithm (EMA).</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
EmaFilter(const float ialpha, const float ibeta)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ialpha</td>
<td>Alpha gain</td>
</tr>

<tr>
<td>ibeta</td>
<td>Beta gain</td>
</tr>
</tbody>
</table>

<h3 id="setgains">setGains</h3>

<pre><code class="language-c++">//Signature
void setGains(const float ialpha, const float ibeta)
</code></pre>

<p>Set new gains for this filter</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ialpha</td>
<td>New alpha gain</td>
</tr>

<tr>
<td>ibeta</td>
<td>New beta gain</td>
</tr>
</tbody>
</table>

<h2 id="filter-abstract">Filter (abstract)</h2>

<p>The <code>Filter</code> class is an interface for data filtering.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
Filter()
</code></pre>

<p>The constructor does not take any parameters.</p>

<h3 id="filter">filter</h3>

<pre><code class="language-c++">//Signature
virtual float filter(const float ireading) = 0;
</code></pre>

<p>Filter an input and return the filtered output.</p>

<h3 id="getoutput">getOutput</h3>

<pre><code class="language-c++">//Signature
virtual float getOutput() const = 0;
</code></pre>

<p>Return the previous output.</p>

<h2 id="genericcontroller">GenericController</h2>

<p>The <code>GenericController</code> class combines motors and a <code>ControlObject</code> into one package that uses the controller to control the motors as a group (all motors get the same controller output).</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
GenericController(const std::array&lt;Motor, motorNum&gt; &amp;imotorList, const std::shared_ptr&lt;ControlObject&gt; &amp;iptr)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imotorList</td>
<td><code>std::array</code> of <code>Motor</code> that will be controlled</td>
</tr>

<tr>
<td>iptr</td>
<td><code>ControlObject</code> used to control the motors</td>
</tr>
</tbody>
</table>

<h3 id="step">step</h3>

<pre><code class="language-c++">//Signature
void step(const float ireading)
</code></pre>

<p>Have the <code>ControlObject</code> do one iteration and then power the motors with the output. This needs to be called every so many milliseconds (15 ms works fine).</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ireading</td>
<td>New sensor reading</td>
</tr>
</tbody>
</table>

<h3 id="settarget">setTarget</h3>

<pre><code class="language-c++">//Signature
void setTarget(const float itarget)
</code></pre>

<p>Set the target value.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>itarget</td>
<td>New target value</td>
</tr>
</tbody>
</table>

<h3 id="getoutput">getOutput</h3>

<pre><code class="language-c++">//Signature
void getOutput() const
</code></pre>

<p>Return the most recent controller output.</p>

<h3 id="setsampletime">setSampleTime</h3>

<pre><code class="language-c++">//Signature
void setSampleTime(const int isampleTime)
</code></pre>

<p>Set the timestep (in ms) between calls to <code>step</code>.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>isampleTime</td>
<td>Timestep between calls to <code>step</code> in ms</td>
</tr>
</tbody>
</table>

<h3 id="setoutputlimits">setOutputLimits</h3>

<pre><code class="language-c++">//Signature
void setOutputLimits(float imax, float imin)
</code></pre>

<p>Set the max and min value for the controller output.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imax</td>
<td>Max output</td>
</tr>

<tr>
<td>imin</td>
<td>Min output</td>
</tr>
</tbody>
</table>

<h3 id="reset">reset</h3>

<pre><code class="language-c++">//Signature
void reset()
</code></pre>

<p>Reset the controller so it will start from zero again.</p>

<h3 id="flipdisable">flipDisable</h3>

<pre><code class="language-c++">//Signature
void flipDisable()
</code></pre>

<p>Change whether the controller is on or off. A controller which is off will output 0.</p>

<h2 id="ime">IME</h2>

<p>The <code>IME</code> class is a simple container for an IME. Inherits from <code>RotarySensor</code>.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
IME(const unsigned int iindex)
IME(const unsigned int iindex, const bool ireversed)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iindex</td>
<td>IME index in the chain</td>
</tr>

<tr>
<td>ireversed</td>
<td>Whether the IME is reversed or not (clockwise turn increases vs. decreases ticks)</td>
</tr>
</tbody>
</table>

<p>This class also has literals available:</p>

<table>
<thead>
<tr>
<th>Literal</th>
<th>IME Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>n_ime</code></td>
<td><code>IME(n, false)</code></td>
</tr>

<tr>
<td><code>n_rime</code></td>
<td><code>IME(n, true)</code></td>
</tr>
</tbody>
</table>

<h3 id="get">get</h3>

<pre><code class="language-c++">//Signature
int get() override
</code></pre>

<p>Return the current tick count.</p>

<h3 id="reset">reset</h3>

<pre><code class="language-c++">//Signature
void reset() override
</code></pre>

<p>Reset the tick count to zero.</p>

<h2 id="mathutil">MathUtil</h2>

<p>The <code>MathUtil</code> class provides <code>static constexpr</code> definitions for commonly used numbers, measurements, and conversion rates.</p>

<table>
<thead>
<tr>
<th>Name</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>analogInToV</td>
<td>286.0</td>
<td>Converts an analog reading to a battery voltage measurement in Volts.</td>
</tr>

<tr>
<td>inchToMM</td>
<td>25.4</td>
<td>Converts one inch to millimeters.</td>
</tr>

<tr>
<td>degreeToRadian</td>
<td>0.01745</td>
<td>Converts one degree to radians.</td>
</tr>

<tr>
<td>radianToDegree</td>
<td>57.2958</td>
<td>Converts one radian to degrees.</td>
</tr>

<tr>
<td>imeHighTorTPR</td>
<td>627.2</td>
<td>The number of ticks an IME returns for one revolution of a 369 motor with high torque gearing.</td>
</tr>

<tr>
<td>imeHighStrTPR</td>
<td>392.0</td>
<td>The number of ticks an IME returns for one revolution of a 369 motor with high speed gearing.</td>
</tr>

<tr>
<td>imeTurboTPR</td>
<td>261.333</td>
<td>The number of ticks an IME returns for one revolution of a 369 motor with turbo gearing.</td>
</tr>

<tr>
<td>ime269TPR</td>
<td>240.448</td>
<td>The number of ticks an IME returns for one revolution of a 269 motor.</td>
</tr>

<tr>
<td>quadEncoderTPR</td>
<td>360.0</td>
<td>The number of ticks a quadrature encoder returns per revolution.</td>
</tr>

<tr>
<td>pi</td>
<td>3.14159265358979323846</td>
<td>The value of pi from GCC&rsquo;s math header (redefined here for convenience)</td>
</tr>
</tbody>
</table>

<h2 id="motor">Motor</h2>

<p>The <code>Motor</code> class provides a wrapper around the default motor utilities.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
explicit constexpr Motor(const unsigned char iport, const int *its)
explicit constexpr Motor(const unsigned char iport, const int isign = 1, const int *its = motor::trueSpeed)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iport</td>
<td>Motor port</td>
</tr>

<tr>
<td>isign</td>
<td><code>1</code> for forward, <code>-1</code> for reversed</td>
</tr>

<tr>
<td>its</td>
<td>TrueSpeed array to linearize the motor controller</td>
</tr>
</tbody>
</table>

<p>This class also has literals available:</p>

<table>
<thead>
<tr>
<th>Literal</th>
<th>Motor Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>n_m</code></td>
<td><code>Motor(m, 1)</code></td>
</tr>

<tr>
<td><code>n_rm</code></td>
<td><code>Motor(m, -1)</code></td>
</tr>
</tbody>
</table>

<h3 id="set">set</h3>

<pre><code class="language-c++">//Signature
virtual void set(const int val) const
</code></pre>

<p>Set the power of this motor.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>val</td>
<td>Motor power</td>
</tr>
</tbody>
</table>

<h3 id="setts">setTS</h3>

<pre><code class="language-c++">//Signature
virtual void set(const int val) const
</code></pre>

<p>Set the power of this motor using trueSpeed.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>val</td>
<td>Motor power</td>
</tr>
</tbody>
</table>

<h2 id="nspid">NsPid</h2>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
NsPid(const PidParams&amp; iparams, const VelMathParams&amp; ivelParams, const float iminVel, const float iscale = 0.1)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iparams</td>
<td><code>PidParams</code> to make the internal PID controller</td>
</tr>

<tr>
<td>ivelParams</td>
<td><code>VelMathParams</code> for the velocity calculations</td>
</tr>

<tr>
<td>iminVel</td>
<td>Minimum velocity at which the controller will start reducing the output power</td>
</tr>

<tr>
<td>iscale</td>
<td>Scale to reduce the output power by</td>
</tr>
</tbody>
</table>

<h3 id="step">step</h3>

<pre><code class="language-c++">//Signature
virtual float step(const float inewReading) override
</code></pre>

<p>Do one iteration of Pid math to compute a new motor power. This needs to be called every so many milliseconds (15 ms works fine).</p>

<p>Calls <code>step</code> from class <code>Pid</code>, and may return a reduced power if the velocity of the process is sufficiently low. The purpose of a low power mode is to prevent motors from stalling once they have reached their target (or if they can&rsquo;t quite reach their target).</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>inewReading</td>
<td>New sensor reading</td>
</tr>
</tbody>
</table>

<h2 id="odomchassiscontroller-abstract">OdomChassisController (abstract)</h2>

<p>The <code>OdomChassisController</code> class inherits from <code>ChassisController</code>. It extends the <code>ChassisController</code> interface to add odometry-based functionality.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
OdomChassisController(OdomParams iparams)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iparams</td>
<td><code>OdomParams</code> (used to make a new <code>Odometry</code>)</td>
</tr>
</tbody>
</table>

<aside class="notice">
This class creates a new task inside its constructor and references a static class (Odometry). Be careful and remember to only make one.
</aside>

<h3 id="drivetopoint">driveToPoint</h3>

<pre><code class="language-c++">//Signature
virtual void driveToPoint(const float ix, const float iy, const bool ibackwards = false, const float ioffset = 0) = 0
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ix</td>
<td>X coordinate of destination</td>
</tr>

<tr>
<td>iy</td>
<td>Y coordinate of destination</td>
</tr>

<tr>
<td>ibackwards</td>
<td>Whether to drive to the destination backwards (default false)</td>
</tr>

<tr>
<td>ioffset</td>
<td>How far back from the destination to stop (default 0)</td>
</tr>
</tbody>
</table>

<p>Drive to the point (<code>ix</code>, <code>iy</code>) in the field frame. If required, the robot will first turn to face the destination point.</p>

<h3 id="turntoangle">turnToAngle</h3>

<pre><code class="language-c++">//Signature
virtual void turnToAngle(const float iangle) = 0
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iangle</td>
<td>Angle to face</td>
</tr>
</tbody>
</table>

<p>Turn to the angle <code>iangle</code> in the field frame.</p>

<h2 id="odomchassiscontrollerpid">OdomChassisControllerPid</h2>

<p>The <code>OdomChassisControllerPid</code> class inherits from <code>OdomChassisController</code> and from <code>ChassisControllerPid</code>. It implements the <code>OdomChassisController</code> interface using PID control.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
OdomChassisControllerPid(const OdomParams&amp; params, const PidParams&amp; idistanceParams, const PidParams&amp; iangleParams)

//Make a new OdomChassisControllerPid using a skid steer model with two motors per side
OdomChassisControllerPid foo(
  OdomParams(
    SkidSteerModelParams&lt;2&gt;({1,3,2,4}, //The four motor ports
                            encoderInit(1,2,false), //Left encoder
                            encoderInit(3,4,true)), //Right encoder
    1.345,     //Distance scale (encoder ticks to mm)
    12.88361), //Turn scale (encoder ticks to deg)
  PidParams(0,0,0),  //Distance PID controller
  PidParams(0,0,0)); //Angle PID controller
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>params</td>
<td><code>OdomParams</code> (used to make a new <code>Odometry</code>)</td>
</tr>

<tr>
<td>idistanceParams</td>
<td><code>PidParams</code> for the distance PID controller</td>
</tr>

<tr>
<td>iangleParams</td>
<td><code>PidParams</code> for the angle PID controller</td>
</tr>
</tbody>
</table>

<h2 id="odometry">Odometry</h2>

<p>The <code>Odometry</code> class tracks the robot as it moves, computing its position in the field frame. It is a singleton so its main method, <code>step</code>, can be called in a task.</p>

<h3 id="setparams">setParams</h3>

<pre><code class="language-c++">//Signature
static void setParams(OdomParams&amp; iparams)
</code></pre>

<p>Set the model, scale, and turnScale parameters.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iparams</td>
<td><code>OdomParams</code></td>
</tr>
</tbody>
</table>

<h3 id="setscales">setScales</h3>

<pre><code class="language-c++">//Signature
static void setScales(const float iscale, const float iturnScale)
</code></pre>

<p>Set the scale and turnScale parameters.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iscale</td>
<td>Driving scale (encoder ticks to mm)</td>
</tr>

<tr>
<td>iturnScale</td>
<td>Turning scale (encoder ticks to degrees)</td>
</tr>
</tbody>
</table>

<h3 id="guessscales">guessScales</h3>

<pre><code class="language-c++">//Signature
static void guessScales(const float chassisDiam, const float wheelDiam, const float ticksPerRev = 360.0)
</code></pre>

<p>Attempt to guess the two odometry scales from chassis and wheel diameter. This might get you close, but it serves only as a quick and temporary fix. The two odometry scales must be found experimentally for your specific robot.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>chassisDiam</td>
<td>Center-to-center wheel base in inches</td>
</tr>

<tr>
<td>wheelDiam</td>
<td>Edge-to-edge wheel diameter in inches</td>
</tr>

<tr>
<td>ticksPerRev</td>
<td>Quadrate encoder ticks per one wheel revolution (default 360)</td>
</tr>
</tbody>
</table>

<h3 id="step">step</h3>

<pre><code class="language-c++">//Signature
static OdomState step()
</code></pre>

<p>Do one iteration of odometry math to compute the new position of the robot. This needs to be called every so many milliseconds (15 ms seems to work fine).</p>

<h3 id="getstate">getState</h3>

<pre><code class="language-c++">//Signature
static OdomState getState()
</code></pre>

<p>Return the last calculated position of the robot.</p>

<h2 id="odomparams">OdomParams</h2>

<p>The <code>OdomParams</code> class encapsulates the parameters an <code>Odometry</code> takes.</p>

<table>
<thead>
<tr>
<th>Member</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>model</td>
<td><code>ChassisModel</code></td>
</tr>

<tr>
<td>scale</td>
<td>Driving scale (encoder ticks to mm)</td>
</tr>

<tr>
<td>turnScale</td>
<td>Turning scale (encoder ticks to degrees)</td>
</tr>
</tbody>
</table>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
OdomParams(const ChassisModelParams&amp; iparams, const float iscale, const float iturnScale)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iparams</td>
<td><code>ChassisModelParams</code> (used to make a new <code>ChassisModel</code>)</td>
</tr>

<tr>
<td>iscale</td>
<td>Driving scale (encoder ticks to mm)</td>
</tr>

<tr>
<td>iturnScale</td>
<td>Turning scale (encoder ticks to degrees)</td>
</tr>
</tbody>
</table>

<h2 id="odomstate">OdomState</h2>

<p>The <code>OdomState</code> class is a simple container for the position of the robot tracked by <code>Odometry</code>.</p>

<table>
<thead>
<tr>
<th>Member</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>x</td>
<td>X coordinate of robot</td>
</tr>

<tr>
<td>y</td>
<td>Y coordinate of robot</td>
</tr>

<tr>
<td>theta</td>
<td>Theta of robot</td>
</tr>
</tbody>
</table>

<h3 id="constructor-1">Constructor</h3>

<pre><code class="language-c++">//Signature
OdomState(const float ix, const float iy, const float itheta)
OdomState()
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ix</td>
<td>X coordinate of robot</td>
</tr>

<tr>
<td>iy</td>
<td>Y coordinate of robot</td>
</tr>

<tr>
<td>itheta</td>
<td>Theta of robot</td>
</tr>
</tbody>
</table>

<h2 id="odommath">OdomMath</h2>

<p>The <code>OdomMath</code> class provides static implementations for common odometry operations.</p>

<h3 id="computedistancetopoint">computeDistanceToPoint</h3>

<pre><code class="language-c++">//Signature
static float computeDistanceToPoint(const float ix, const float iy, const OdomState&amp; istate)
</code></pre>

<p>Calculate the distance from the robot to a point, (<code>ix</code>, <code>iy</code>).</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ix</td>
<td>X coordinate</td>
</tr>

<tr>
<td>iy</td>
<td>Y coordinate</td>
</tr>

<tr>
<td>istate</td>
<td>Odometry state</td>
</tr>
</tbody>
</table>

<h3 id="computeangletopoint">computeAngleToPoint</h3>

<pre><code class="language-c++">//Signature
static float computeAngleToPoint(const float ix, const float iy, const OdomState&amp; istate)
</code></pre>

<p>Calculate the angle from the robot to a point, (<code>ix</code>, <code>iy</code>).</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ix</td>
<td>X coordinate</td>
</tr>

<tr>
<td>iy</td>
<td>Y coordinate</td>
</tr>

<tr>
<td>istate</td>
<td>Odometry state</td>
</tr>
</tbody>
</table>

<h3 id="computedistanceandangletopoint">computeDistanceAndAngleToPoint</h3>

<pre><code class="language-c++">//Signature
static DistanceAndAngle computeDistanceAndAngleToPoint(const float ix, const float iy, const OdomState&amp; istate)
</code></pre>

<p>Calculate the distance and the angle from the robot to a point, (<code>ix</code>, <code>iy</code>).</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ix</td>
<td>X coordinate</td>
</tr>

<tr>
<td>iy</td>
<td>Y coordinate</td>
</tr>

<tr>
<td>istate</td>
<td>Odometry state</td>
</tr>
</tbody>
</table>

<h2 id="pid">Pid</h2>

<p>The <code>Pid</code> class implements the Pid algorithm, with some quality-of-life changes to support online tuning. Inherits from <code>ControlObject</code>.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
Pid(const float ikP, const float ikI, const float ikD, const float ikBias = 0)
Pid(const PidParams&amp; params)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ikP</td>
<td>Proportional gain</td>
</tr>

<tr>
<td>ikI</td>
<td>Integral gain</td>
</tr>

<tr>
<td>ikD</td>
<td>Derivative gain</td>
</tr>

<tr>
<td>ikBias</td>
<td>Controller bias (this value added to output, default 0)</td>
</tr>

<tr>
<td>params</td>
<td><code>PidParams</code></td>
</tr>
</tbody>
</table>

<h3 id="step">step</h3>

<pre><code class="language-c++">//Signature
virtual float step(const float inewReading) override
</code></pre>

<p>Do one iteration of Pid math to compute a new motor power. This needs to be called every so many milliseconds (15 ms works fine).</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>inewReading</td>
<td>New sensor reading</td>
</tr>
</tbody>
</table>

<h3 id="settarget">setTarget</h3>

<pre><code class="language-c++">//Signature
void setTarget(const float itarget) override
</code></pre>

<p>Set the target value.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>itarget</td>
<td>New target value</td>
</tr>
</tbody>
</table>

<h3 id="getoutput">getOutput</h3>

<pre><code class="language-c++">//Signature
float getOutput() const
</code></pre>

<p>Return the most recent controller output.</p>

<h3 id="geterror">getError</h3>

<pre><code class="language-c++">//Signature
virtual float getError() const = 0
</code></pre>

<p>Return the most recent controller error.</p>

<h3 id="setgains">setGains</h3>

<pre><code class="language-c++">//Signature
void setGains(const float ikP, const float ikI, const float ikD, const float ikBias = 0)
</code></pre>

<p>Set new controller gains and bias.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ikP</td>
<td>Proportional gain</td>
</tr>

<tr>
<td>ikI</td>
<td>Integral gain</td>
</tr>

<tr>
<td>ikD</td>
<td>Derivative gain</td>
</tr>

<tr>
<td>ikBias</td>
<td>Controller bias (this value added to output, default 0)</td>
</tr>
</tbody>
</table>

<h3 id="setsampletime">setSampleTime</h3>

<pre><code class="language-c++">//Signature
void setSampleTime(const int isampleTime) override
</code></pre>

<p>Set the timestep (in ms) between calls to <code>step</code>.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>isampleTime</td>
<td>Timestep between calls to <code>step</code> in ms</td>
</tr>
</tbody>
</table>

<h3 id="setoutputlimits">setOutputLimits</h3>

<pre><code class="language-c++">//Signature
void setOutputLimits(float imax, float imin) override
</code></pre>

<p>Set the max and min value for the controller output.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imax</td>
<td>Max output</td>
</tr>

<tr>
<td>imin</td>
<td>Min output</td>
</tr>
</tbody>
</table>

<h3 id="setintegrallimits">setIntegralLimits</h3>

<pre><code class="language-c++">//Signature
void setIntegralLimits(float imax, float imin)
</code></pre>

<p>Set the max and min value for the integrator sum.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imax</td>
<td>Max integrator value</td>
</tr>

<tr>
<td>imin</td>
<td>Min integrator value</td>
</tr>
</tbody>
</table>

<h3 id="reset">reset</h3>

<pre><code class="language-c++">//Signature
void reset() override
</code></pre>

<p>Reset the controller so it will start from zero again.</p>

<h3 id="setintegratorreset">setIntegratorReset</h3>

<pre><code class="language-c++">//Signature
void setIntegratorReset(bool iresetOnZero)
</code></pre>

<p>Set whether the integrator should be cleared when the controller&rsquo;s error is zero or changes sign.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iresetOnZero</td>
<td>Whether the integrator should be cleared when the controller&rsquo;s error is zero or changes sign</td>
</tr>
</tbody>
</table>

<h3 id="flipdisable">flipDisable</h3>

<pre><code class="language-c++">//Signature
void flipDisable() override
</code></pre>

<p>Change whether the controller is on or off. A controller which is off will output 0.</p>

<h2 id="pidparams">PidParams</h2>

<p>The <code>PidParams</code> class encapsulates the parameters a <code>Pid</code> takes.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>kP</td>
<td>Proportional gain</td>
</tr>

<tr>
<td>kI</td>
<td>Integral gain</td>
</tr>

<tr>
<td>kD</td>
<td>Derivative gain</td>
</tr>

<tr>
<td>kBias</td>
<td>Controller bias (this value added to output)</td>
</tr>
</tbody>
</table>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
PidParams(const float ikP, const float ikI, const float ikD, const float ikBias = 0)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ikP</td>
<td>Proportional gain</td>
</tr>

<tr>
<td>ikI</td>
<td>Integral gain</td>
</tr>

<tr>
<td>ikD</td>
<td>Derivative gain</td>
</tr>

<tr>
<td>ikBias</td>
<td>Controller bias (this value added to output, default 0)</td>
</tr>
</tbody>
</table>

<h2 id="potentiometer">Potentiometer</h2>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
explicit constexpr Potentiometer()
explicit constexpr Potentiometer(const unsigned char iport)
explicit constexpr Potentiometer(const unsigned char iport, const bool iinverted)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iport</td>
<td>Analog input port</td>
</tr>

<tr>
<td>iinverted</td>
<td>Whether the potentiometer is inverted (range is 0-&gt;4095 or 4095-&gt;0)</td>
</tr>
</tbody>
</table>

<p>This class also has literals available:</p>

<table>
<thead>
<tr>
<th>Literal</th>
<th>Potentiometer Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>n_p</code></td>
<td><code>Potentiometer(n, false)</code></td>
</tr>

<tr>
<td><code>n_ip</code></td>
<td><code>Potentiometer(n, true)</code></td>
</tr>
</tbody>
</table>

<h3 id="get">get</h3>

<pre><code class="language-c++">//Signature
int get() const
</code></pre>

<p>Return the value of this potentiometer.</p>

<h2 id="quadencoder">QuadEncoder</h2>

<p>The <code>QuadEncoder</code> class is a simple container for an encoder. Inherits from <code>RotarySensor</code>.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
QuadEncoder(const unsigned char iportTop, const unsigned char iportBottom)
QuadEncoder(const unsigned char iportTop, const unsigned char iportBottom, const bool ireversed)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iportTop</td>
<td>Top digital in port</td>
</tr>

<tr>
<td>iportBottom</td>
<td>Bottom digital in port</td>
</tr>

<tr>
<td>ireversed</td>
<td>Whether the encoder is reversed or not (clockwise turn increases vs. decreases ticks)</td>
</tr>
</tbody>
</table>

<h3 id="get">get</h3>

<pre><code class="language-c++">//Signature
int get() override
</code></pre>

<p>Return the current tick count.</p>

<h3 id="reset">reset</h3>

<pre><code class="language-c++">//Signature
void reset() override
</code></pre>

<p>Reset the tick count to zero.</p>

<h2 id="rangefinder">RangeFinder</h2>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
RangeFinder(const unsigned char iportTop, const unsigned char iportBottom)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iportTop</td>
<td>Top digital port</td>
</tr>

<tr>
<td>iportBottom</td>
<td>Bottom digital port</td>
</tr>
</tbody>
</table>

<h3 id="get">get</h3>

<pre><code class="language-c++">//Signature
int get()
</code></pre>

<p>Return the current measured range in centimeters.</p>

<h3 id="getfiltered">getFiltered</h3>

<pre><code class="language-c++">//Signature
int getFiltered()
</code></pre>

<p>Return the median measured range in centimeters. The median is measured across the previous five measurements.</p>

<h2 id="rotarysensor-abstract">RotarySensor (abstract)</h2>

<p>The <code>RotarySensor</code> class is a simple container for a sensor which spins indefinitely to measure rotation, like a <code>QuadEncoder</code> or an <code>IME</code>.</p>

<h3 id="get">get</h3>

<pre><code class="language-c++">//Signature
virtual int get() = 0
</code></pre>

<p>Return the current tick count.</p>

<h3 id="reset">reset</h3>

<pre><code class="language-c++">//Signature
virtual void reset() = 0
</code></pre>

<p>Reset the tick count to zero.</p>

<h2 id="skidsteermodel">SkidSteerModel</h2>

<p>The <code>SkidSteerModel</code> class inherits from <code>ChassisModel</code> and takes a template parameter <code>size_t motorsPerSide</code> (the number of motors per each of the two sides of the chassis). It is a model for a skid steer drive (also called a tank drive).</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
SkidSteerModel(const std::array&lt;Motor, motorsPerSide * 2&gt;&amp; imotorList, const QuadEncoder&amp; ileftEnc, const QuadEncoder&amp; irightEnc)
SkidSteerModel(const std::array&lt;Motor, motorsPerSide * 2&gt;&amp; imotorList, const IME&amp; ileftIME, const IME&amp; irightIME)
SkidSteerModel(const SkidSteerModelParams&lt;motorsPerSide&gt;&amp; iparams)
SkidSteerModel(const SkidSteerModel&lt;motorsPerSide&gt;&amp; other)

//Construct a SkidSteerModel with four motors (two per side) and two encoders
//Left side motors are ports 1 and 3
//Right side motors are ports 2 and 4
//Right side encoder is reversed because it is a mirror of the left side
SkidSteerModel&lt;2&gt; foo({1, 3, 2, 4}, QuadEncoder(1, 2, false), QuadEncoder(3, 4, true));
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imotorList</td>
<td>The left and right side motors for the drive in the format, <code>{left motors, right motors}</code></td>
</tr>

<tr>
<td>ileftEnc</td>
<td>The quadrature encoder for the left side</td>
</tr>

<tr>
<td>irightEnc</td>
<td>The quadrature encoder for the right side</td>
</tr>

<tr>
<td>ileftIME</td>
<td>The IME for the left side</td>
</tr>

<tr>
<td>irightIME</td>
<td>The IME for the right side</td>
</tr>
</tbody>
</table>

<h2 id="skidsteermodelparams">SkidSteerModelParams</h2>

<p>The <code>SkidSteerModelParams</code> class inherits from <code>ChassisModelParams</code>. It encapsulates the parameters a <code>SkidSteerModel</code> takes.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
SkidSteerModelParams(const std::array&lt;Motor, motorsPerSide * 2&gt;&amp; imotorList, const QuadEncoder&amp; ileftEnc, const QuadEncoder&amp; irightEnc):
SkidSteerModelParams(const std::array&lt;Motor, motorsPerSide * 2&gt;&amp; imotorList, const IME&amp; ileftIME, const IME&amp; irightIME)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imotorList</td>
<td>The left and right side motors for the drive in the format, <code>{left motors, right motors}</code></td>
</tr>

<tr>
<td>ileftEnc</td>
<td>The quadrature encoder for the left side</td>
</tr>

<tr>
<td>irightEnc</td>
<td>The quadrature encoder for the right side</td>
</tr>

<tr>
<td>ileftIME</td>
<td>The IME for the left side</td>
</tr>

<tr>
<td>irightIME</td>
<td>The IME for the right side</td>
</tr>
</tbody>
</table>

<h2 id="slewmotor">SlewMotor</h2>

<p>The <code>SlewMotor</code> class adds a slew rate to the <code>Motor</code> class.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
SlewMotor(const Motor&amp; imotor, const float islewRate)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imotor</td>
<td>Motor to slew</td>
</tr>

<tr>
<td>islewRate</td>
<td>Slew rate</td>
</tr>
</tbody>
</table>

<h3 id="set">set</h3>

<pre><code class="language-c++">//Signature
virtual void set(const int val) const
</code></pre>

<p>Slew the power of this motor up to <code>val</code>.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>val</td>
<td>Target motor power</td>
</tr>
</tbody>
</table>

<h3 id="setts">setTS</h3>

<pre><code class="language-c++">//Signature
virtual void set(const int val) const
</code></pre>

<p>Slew the power of this motor up to <code>val</code> using trueSpeed.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>val</td>
<td>Target motor power</td>
</tr>
</tbody>
</table>

<h2 id="timer">Timer</h2>

<p>The <code>Timer</code> class has timing-related utilities to make measuring time differences and writing non-blocking code in loops easier.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
Timer()
</code></pre>

<p>The constructor does not take any parameters.</p>

<h3 id="getdt">getDt</h3>

<pre><code class="language-c++">//Signature
unsigned long getDt()
</code></pre>

<p>Return the time passed in ms since the last time this function was called.</p>

<h3 id="getstartingtime">getStartingTime</h3>

<pre><code class="language-c++">//Signature
unsigned long getStartingTime() const
</code></pre>

<p>Return the time in ms the timer was constructed.</p>

<h3 id="getdtfromstart">getDtFromStart</h3>

<pre><code class="language-c++">//Signature
unsigned long getDtFromStart() const
</code></pre>

<p>Return the time passed in ms since the timer was constructed.</p>

<h3 id="placemark">placeMark</h3>

<pre><code class="language-c++">//Signature
void placeMark()
</code></pre>

<p>Place a time marker. Placing another marker will overwrite the previous one.</p>

<h3 id="placehardmark">placeHardMark</h3>

<pre><code class="language-c++">//Signature
void placeHardMark()
</code></pre>

<p>Place a hard time marker. Placing another hard marker will not overwrite the previous one; instead, <code>clearHardMark()</code> must be called before another can be placed.</p>

<h3 id="clearhardmark">clearHardMark</h3>

<pre><code class="language-c++">//Signature
unsigned long clearHardMark()
</code></pre>

<p>Clear and return the current hard marker.</p>

<h3 id="getdtfrommark">getDtFromMark</h3>

<pre><code class="language-c++">//Signature
unsigned long getDtFromMark()
</code></pre>

<p>Return the time in ms since the marker was placed.</p>

<h3 id="getdtfromhardmark">getDtFromHardMark</h3>

<pre><code class="language-c++">//Signature
unsigned long getDtFromHardMark()
</code></pre>

<p>Return the time in ms since the hard marker was placed.</p>

<h3 id="repeat">repeat</h3>

<pre><code class="language-c++">//Signature
bool repeat(unsigned long ms)
</code></pre>

<p>Return true when the input time period <code>ms</code> has passed, and then reset. Meant to be used in loops to execute a block of code every so many ms without blocking the loop.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ms</td>
<td>Number of milliseconds between calls of <code>repeat</code> that return true</td>
</tr>
</tbody>
</table>

<h2 id="velmath">VelMath</h2>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
VelMath(const float iticksPerRev, const float iQ = 0.0001, const float iR = ipow(0.2, 2))
VelMath(const VelMathParams&amp; iparams)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iticksPerRev</td>
<td>Encoder ticks per one revolution</td>
</tr>

<tr>
<td>iQ</td>
<td><code>EKF</code> Process variance</td>
</tr>

<tr>
<td>iR</td>
<td><code>EKF</code> Measurement variance</td>
</tr>
</tbody>
</table>

<h3 id="step">step</h3>

<pre><code class="language-c++">//Signature
float step(const float inewPos)
</code></pre>

<p>Calculate, filter, and return a new velocity. This need to be called every so many milliseconds (not any faster than 15 ms).</p>

<h3 id="setticksperrev">setTicksPerRev</h3>

<pre><code class="language-c++">//Signature
void setTicksPerRev(const float iTPR)
</code></pre>

<p>Set a new ticks per rev value.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>iTPR</td>
<td>Encoder ticks per one revolution</td>
</tr>
</tbody>
</table>

<h3 id="getoutput">getOutput</h3>

<pre><code class="language-c++">//Signature
float getOutput() const
</code></pre>

<p>Return the most recent velocity.</p>

<h3 id="getdiff">getDiff</h3>

<pre><code class="language-c++">//Signature
float getDiff() const
</code></pre>

<p>Return the difference between the last and second to last velocity. Dividing this value by the sample time would give an acceleration.</p>

<h2 id="velpid">VelPid</h2>

<p>The <code>VelPid</code> class implements the Pid algorithm for the velocity domain, with some quality-of-life changes to support online tuning. Inherits from <code>ControlObject</code>.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
VelPid(const float ikP, const float ikD)
VelPid(const float ikP, const float ikD, const VelMath&amp; ivelMath)
VelPid(const VelPidParams&amp; params)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ikP</td>
<td>Proportional gain</td>
</tr>

<tr>
<td>ikD</td>
<td>Derivative gain</td>
</tr>

<tr>
<td>ivelMath</td>
<td><code>VelMath</code></td>
</tr>

<tr>
<td>params</td>
<td><code>VelPidParams</code></td>
</tr>
</tbody>
</table>

<h3 id="stepvel">stepVel</h3>

<pre><code class="language-c++">//Signature
virtual float stepVel(const float inewReading)
</code></pre>

<p>Do one iteration of velocity math to compute a new filtered velocity. This is only meant to be used separately from <code>step</code> if you only want to compute a new velocity. Don&rsquo;t call <code>stepVel</code> if you are already calling <code>step</code> because <code>step</code> will call <code>stepVel</code> on its own.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>inewReading</td>
<td>New sensor reading</td>
</tr>
</tbody>
</table>

<h3 id="step">step</h3>

<pre><code class="language-c++">//Signature
virtual float step(const float inewReading)
</code></pre>

<p>Do one iteration of Pid math to compute a new motor power. This needs to be called every so many milliseconds (15 ms works fine).</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>inewReading</td>
<td>New sensor reading</td>
</tr>
</tbody>
</table>

<h3 id="settarget">setTarget</h3>

<pre><code class="language-c++">//Signature
void setTarget(const float itarget)
</code></pre>

<p>Set the target value.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>itarget</td>
<td>New target value</td>
</tr>
</tbody>
</table>

<h3 id="getoutput">getOutput</h3>

<pre><code class="language-c++">//Signature
float getOutput() const
</code></pre>

<p>Return the most recent controller output.</p>

<h3 id="geterror">getError</h3>

<pre><code class="language-c++">//Signature
virtual float getError() const = 0
</code></pre>

<p>Return the most recent controller error.</p>

<h3 id="setsampletime">setSampleTime</h3>

<pre><code class="language-c++">//Signature
void setSampleTime(const int isampleTime)
</code></pre>

<p>Set the timestep (in ms) between calls to <code>step</code>.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>isampleTime</td>
<td>Timestep between calls to <code>step</code> in ms</td>
</tr>
</tbody>
</table>

<h3 id="setoutputlimits">setOutputLimits</h3>

<pre><code class="language-c++">//Signature
void setOutputLimits(float imax, float imin)
</code></pre>

<p>Set the max and min value for the controller output.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imax</td>
<td>Max output</td>
</tr>

<tr>
<td>imin</td>
<td>Min output</td>
</tr>
</tbody>
</table>

<h3 id="reset">reset</h3>

<pre><code class="language-c++">//Signature
void reset()
</code></pre>

<p>Reset the controller so it will start from zero again.</p>

<h3 id="flipdisable">flipDisable</h3>

<pre><code class="language-c++">//Signature
void flipDisable()
</code></pre>

<p>Change whether the controller is on or off. A controller which is off will output 0.</p>

<h3 id="setfiltergains">setFilterGains</h3>

<pre><code class="language-c++">//Signature
void setFilterGains(const float alpha, const float beta)
</code></pre>

<p>Set new gains for the <code>DemaFilter</code></p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>alpha</td>
<td>Alpha gain</td>
</tr>

<tr>
<td>beta</td>
<td>Beta gain</td>
</tr>
</tbody>
</table>

<h3 id="setticksperrev">setTicksPerRev</h3>

<pre><code class="language-c++">//Signature
void setTicksPerRev(const float tpr)
</code></pre>

<p>Set the number of measurement units per revolution. Default is 360 (quadrature encoder).</p>

<h2 id="velpidparams">VelPidParams</h2>

<p>The <code>VelPidParams</code> class encapsulates the parameters a <code>VelPid</code> takes.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>kP</td>
<td>Proportional gain</td>
</tr>

<tr>
<td>kD</td>
<td>Derivative gain</td>
</tr>
</tbody>
</table>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
VelPidParams(const float ikP, const float ikD)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ikP</td>
<td>Proportional gain</td>
</tr>

<tr>
<td>ikD</td>
<td>Derivative gain</td>
</tr>
</tbody>
</table>

<h2 id="xdrivemodel">XDriveModel</h2>

<p>The <code>XDriveModel</code> class inherits from <code>ChassisModel</code> and takes a template parameter <code>size_t motorsPerCorner</code> (the number of motors per each of the four corners of the chassis). It is a model for an x-drive.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
XDriveModelParams(const std::array&lt;unsigned char, motorsPerCorner * 4&gt;&amp; imotorList, const QuadEncoder&amp; ileftEnc, const QuadEncoder&amp; irightEnc):
XDriveModelParams(const std::array&lt;unsigned char, motorsPerCorner * 4&gt;&amp; imotorList, const IME&amp; ileftIME, const IME&amp; irightIME)
XDriveModel(const XDriveModelParams&lt;motorsPerCorner&gt;&amp; iparams)
XDriveModel(const XDriveModel&lt;motorsPerCorner&gt;&amp; other)

//Construct an XDriveModel with four motors (one per corner) and two encoders
//Top left motor is port 1, top right motor is port 2
//Bottom right motor is port 3, bottom left motor is port 4
//Right side encoder is reversed because it is a mirror of the left side
XDriveModel&lt;1&gt; foo({1, 2, 3, 4}, QuadEncoder(1, 2, false), QuadEncoder(3, 4, true));

//Construct an XDriveModel with eight motors (two per corner) and two encoders
//Top left motors are ports 1 and 2, top right motors are ports 3 and 4
//Bottom right motors are ports 5 and 6, bottom left motors are ports 7 and 8
//Right side encoder is reversed because it is a mirror of the left side
XDriveModel&lt;2&gt; foo({1, 2, 3, 4, 5, 6, 7, 8}, QuadEncoder(1, 2, false), QuadEncoder(3, 4, true));
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imotorList</td>
<td>The chassis motors for the drive in the clockwise format, <code>{top left motors, top right motors, bottom right motors, bottom left motors}</code></td>
</tr>

<tr>
<td>ileftEnc</td>
<td>The quadrature encoder for the left side</td>
</tr>

<tr>
<td>irightEnc</td>
<td>The quadrature encoder for the right side</td>
</tr>

<tr>
<td>ileftIME</td>
<td>The IME for the left side</td>
</tr>

<tr>
<td>irightIME</td>
<td>The IME for the right side</td>
</tr>
</tbody>
</table>

<h3 id="xarcade">xArcade</h3>

<pre><code class="language-c++">//Signature
void xArcade(const int verticalVal, const int horizontalVal, const int rotateVal)
</code></pre>

<p>Specifically for an x-drive, power the motors like arcade drive with a channel for rotation.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>verticalVal</td>
<td>Motor power for the vertical component of movement</td>
</tr>

<tr>
<td>horizontalVal</td>
<td>Motor power for the horizontal component of movement</td>
</tr>

<tr>
<td>rotateVal</td>
<td>Motor power for rotation</td>
</tr>
</tbody>
</table>

<h2 id="xdrivemodelparams">XDriveModelParams</h2>

<p>The <code>XDriveModelParams</code> class inherits from <code>ChassisModelParams</code>. It encapsulates the parameters an <code>XDriveModel</code> takes.</p>

<h3 id="constructor">Constructor</h3>

<pre><code class="language-c++">//Signature
XDriveModelParams(const std::array&lt;unsigned char, motorsPerCorner * 4&gt;&amp; imotorList, const QuadEncoder&amp; ileftEnc, const QuadEncoder&amp; irightEnc):
XDriveModelParams(const std::array&lt;unsigned char, motorsPerCorner * 4&gt;&amp; imotorList, const IME&amp; ileftIME, const IME&amp; irightIME)
</code></pre>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>imotorList</td>
<td>The chassis motors for the drive in the clockwise format, <code>{top left motors, top right motors, bottom right motors, bottom left motors}</code></td>
</tr>

<tr>
<td>ileftEnc</td>
<td>The quadrature encoder for the left side</td>
</tr>

<tr>
<td>irightEnc</td>
<td>The quadrature encoder for the right side</td>
</tr>

<tr>
<td>ileftIME</td>
<td>The IME for the left side</td>
</tr>

<tr>
<td>irightIME</td>
<td>The IME for the right side</td>
</tr>
</tbody>
</table>
</p>


			<aside class="copyright" role="note">
				
				Documentation built with
				<a href="https://www.gohugo.io" target="_blank">Hugo</a>
				using the
				<a href="http://github.com/digitalcraftsman/hugo-material-docs" target="_blank">Material</a> theme.
			</aside>

			<footer class="footer">
				

<nav class="pagination" aria-label="Footer">
  <div class="previous">
  
      <a href="https://okapilib.github.io/OkapiLib/tutorials/pidtutorial/" title="">
        <span class="direction">
          Previous
        </span>
        <div class="page">
          <div class="button button-previous" role="button" aria-label="Previous">
            <i class="icon icon-back"></i>
          </div>
          <div class="stretch">
            <div class="title">
              
            </div>
          </div>
        </div>
      </a>
  
  </div>

  <div class="next">
  
      <a href="https://okapilib.github.io/OkapiLib/getting-started/" title="Getting started">
        <span class="direction">
          Next
        </span>
        <div class="page">
          <div class="stretch">
            <div class="title">
              Getting started
            </div>
          </div>
          <div class="button button-next" role="button" aria-label="Next">
            <i class="icon icon-forward"></i>
          </div>
        </div>
      </a>
  
  </div>
</nav>





			</footer>
		</div>
	</article>

	<div class="results" role="status" aria-live="polite">
		<div class="scrollable">
			<div class="wrapper">
				<div class="meta"></div>
				<div class="list"></div>
			</div>
		</div>
	</div>
</main>

    <script>
    
      var base_url = 'https:\/\/okapilib.github.io\/OkapiLib\/';
      var repo_id  = 'OkapiLib\/OkapiLib';
    
    </script>

    <script src="https://okapilib.github.io/OkapiLib/javascripts/application.js"></script>
    

    <script>
      /* Add headers to scrollspy */
      var headers   = document.getElementsByTagName("h2");
      var scrollspy = document.getElementById('scrollspy');

      if(scrollspy) {
        if(headers.length > 0) {
          for(var i = 0; i < headers.length; i++) {
            var li = document.createElement("li");
            li.setAttribute("class", "anchor");

            var a  = document.createElement("a");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", headers[i].innerHTML);
            a.innerHTML = headers[i].innerHTML;

            li.appendChild(a)
            scrollspy.appendChild(li);
          }
        } else {
          scrollspy.parentElement.removeChild(scrollspy)
        }


        /* Add permanent link next to the headers */
        var headers = document.querySelectorAll("h1, h2, h3, h4, h5, h6");

        for(var i = 0; i < headers.length; i++) {
            var a = document.createElement("a");
            a.setAttribute("class", "headerlink");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", "Permanent link")
            a.innerHTML = "#";
            headers[i].appendChild(a);
        }
      }
    </script>

    
      <script>
        (function(i,s,o,g,r,a,m){
          i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||
          []).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;
          m.parentNode.insertBefore(a,m)
        })(window, document,
          'script', '//www.google-analytics.com/analytics.js', 'ga');
         
        ga('create', 'UA-108357936-1', 'auto');
        ga('set', 'anonymizeIp', true);
        ga('send', 'pageview');
         
        var buttons = document.querySelectorAll('a');
        Array.prototype.map.call(buttons, function(item) {
          if (item.host != document.location.host) {
            item.addEventListener('click', function() {
              var action = item.getAttribute('data-action') || 'follow';
              ga('send', 'event', 'outbound', action, item.href);
            });
          }
        });
         
        var query = document.querySelector('.query');
        query.addEventListener('blur', function() {
          if (this.value) {
            var path = document.location.pathname;
            ga('send', 'pageview', path + '?q=' + this.value);
          }
        });
      </script>
    

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>

